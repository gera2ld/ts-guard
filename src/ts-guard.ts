import { createHash } from 'node:crypto';
import { mkdir, writeFile } from 'node:fs/promises';
import { resolve, relative, dirname } from 'node:path';
import {
  CallExpression,
  Project,
  ProjectOptions,
  ScriptTarget,
  ts,
  Type,
} from 'ts-morph';

const TS_GUARD_TEMPLATE = process.env.TS_GUARD_TEMPLATE as string;

enum DataType {
  others,
  object,
  array,
  tuple,
}

interface ITypeInfo {
  type: DataType;
  /**
   * For `DataType.array`, `param['']` is considered the type of its children.
   * For `DataType.object`, `param` should be `{ [key]: childType }`.
   * For others, `param` is ignored.
   */
  param?: Record<
    string,
    {
      /** The key of an existing type. */
      ref: string;
      optional?: boolean;
    }
  >;
}

interface ITypeMeta {
  info: ITypeInfo;
  /** The name of the type for debugging purpose. */
  text?: string;
}

interface ITypeMap {
  [key: string]: ITypeMeta;
}

type IGuardRule = [ref: string, name?: string, optional?: 0 | 1];

/** Translate `ITypeInfo` into a more machine friendly format. */
interface IGuardType {
  type: DataType;
  /**
   * The field rules of this object, only applicable when the current field
   * is an object or an array of objects.
   */
  rules?: IGuardRule[];
}

type IGuardMap = Record<string, IGuardType>;

type IGuardInfo = [CallExpression<ts.CallExpression>, string];

export interface ITsGuardBuildOptions {
  /**
   * The root directory of ts files that ts-guard should compile.
   */
  rootDir: string;
  /**
   * The path of the file that contains type data generated by ts-guard.
   */
  guardFile?: string;
}

export function compile(
  buildOptions: ITsGuardBuildOptions,
  projectOptions?: ProjectOptions,
) {
  /**
   * `outDir` is passed to tsc as `compilerOptions.outDir` and used to calculate file paths in the memory.
   * It does't affect the path of files written to the local file system.
   */
  const outDir = 'lib';
  const project = new Project({
    tsConfigFilePath: 'tsconfig.json',
    ...projectOptions,
    compilerOptions: {
      ...projectOptions?.compilerOptions,
      sourceMap: false,
      target: ScriptTarget.ESNext,
      rootDir: '.',
      outDir,
    },
  });
  const { rootDir } = buildOptions;
  let guardFile = buildOptions.guardFile || `${rootDir}/_ts_guard.ts`;
  guardFile = guardFile.replace(/\.jsx?$/, '.ts');
  updateGuards(project, scanFiles(project), guardFile);
  // project.emitSync();
  const result = project.emitToMemory();

  const baseDir = resolve(outDir, rootDir);
  const files: Record<string, string> = {};

  for (const file of result.getFiles()) {
    const relpath = relative(baseDir, file.filePath);
    if (!relpath.startsWith('../')) {
      files[relpath] = file.text;
    }
  }

  return files;
}

export async function writeFiles(
  files: Record<string, string>,
  outDir: string,
  callbacks?: {
    onWriteFile?: (relpath: string) => void;
  },
) {
  for (const [relpath, content] of Object.entries(files)) {
    const fullPath = resolve(outDir, relpath);
    await mkdir(dirname(fullPath), { recursive: true });
    await writeFile(fullPath, content, 'utf8');
    callbacks?.onWriteFile?.(relpath);
  }
}

function getGuardInfo(
  project: Project,
  node: CallExpression<ts.CallExpression>,
  typeMap: ITypeMap,
) {
  const propArg = node.getArguments()[1];
  const prop = propArg?.getType().getLiteralValueOrThrow() as string;
  const typeChecker = project.getTypeChecker();
  const signature = typeChecker.getResolvedSignatureOrThrow(node);
  const responseType = typeChecker.getReturnTypeOfSignature(signature);
  const type = prop
    ? responseType.getPropertyOrThrow(prop).getTypeAtLocation(node)
    : responseType;
  const text = type.getText().split('.').pop();
  const key = addTypeInfo(typeMap, type, text);
  return [node, `/* ${text} */ ${JSON.stringify(key)}`] as IGuardInfo;
}

function scanFiles(project: Project) {
  const sourceFiles = project.getSourceFiles();
  const filesWithGuard: [string, IGuardInfo[]][] = [];
  const typeMap: ITypeMap = {};
  for (const sourceFile of sourceFiles) {
    // console.log("Visit file:", sourceFile.getFilePath());
    const guards: IGuardInfo[] = [];
    sourceFile.forEachDescendant((node) => {
      if (!node.isKind(ts.SyntaxKind.CallExpression)) {
        return;
      }
      const identifier = node.getExpressionIfKind(ts.SyntaxKind.Identifier);
      const identifierName = identifier?.getText();
      let guard: IGuardInfo | undefined;
      if (identifierName === 'tsGuard') {
        guard = getGuardInfo(project, node, typeMap);
      }
      if (guard) {
        guards.push(guard);
      }
    });
    if (guards.length > 0) {
      filesWithGuard.push([sourceFile.getFilePath(), guards]);
    }
  }
  return { typeMap, files: filesWithGuard };
}

function updateGuards(
  project: Project,
  { typeMap, files }: { typeMap: ITypeMap; files: [string, IGuardInfo[]][] },
  guardFilePath: string,
) {
  const guardMap = getRulesFromTypes(typeMap);
  const rules = Object.entries(guardMap).map(
    ([key, guard]) =>
      `/* ${typeMap[key].text || key} */
${JSON.stringify(key)}: ${JSON.stringify([guard.type, guard.rules])}`,
  );
  const template = TS_GUARD_TEMPLATE.replace(
    /{\s*\/\* RULE_MAP \*\/\s*}/,
    `{\n${rules.join(',\n')}\n}`,
  );
  const guardFile = project.createSourceFile(guardFilePath, template);
  for (const [path, info] of files) {
    const sourceFile = project.getSourceFileOrThrow(path);
    let guardPath = sourceFile.getRelativePathTo(guardFile);
    guardPath = guardPath.replace(/\.tsx?$/, '.js');
    if (!guardPath.startsWith('.')) {
      guardPath = `./${guardPath}`;
    }
    sourceFile.addImportDeclaration({
      moduleSpecifier: guardPath,
      namedImports: ['$tsGuard$'],
    });
    for (const [node, id] of info) {
      const identifier = node.getExpressionIfKind(ts.SyntaxKind.Identifier);
      if (!identifier) {
        continue;
      }
      identifier.replaceWithText('$tsGuard$');
      node.insertArgument(0, id);
    }
  }
}

function getTypeHash(typeInfo: ITypeInfo): string {
  const payload = [
    typeInfo.type,
    ...sortedEntries(typeInfo.param).map(([key, { ref, optional }]) => [
      key,
      ref || '',
      +!!optional,
    ]),
  ].join(':');
  return createHash('sha256').update(payload).digest('hex').slice(0, 4);
}

function isSupportedObjectType(type: Type<ts.Type>) {
  return (
    type.isArray() ||
    type.isTuple() ||
    type.isClassOrInterface() ||
    type.isObject()
  );
}

function isPrimitiveType(type: Type<ts.Type>) {
  return (
    type.isNull() ||
    type.isUndefined() ||
    type.isVoid() ||
    type.isNumber() ||
    type.isBoolean() ||
    type.isString() ||
    type.isLiteral()
  );
}

function getOnlyObjectType(type: Type<ts.UnionType>) {
  const unionTypes = type.getUnionTypes();
  const objectTypes = unionTypes.filter((type) => !isPrimitiveType(type));
  if (objectTypes.length === 1) {
    const [objectType] = objectTypes;
    if (isSupportedObjectType(objectType)) {
      return objectType;
    }
  }
}

function addTypeInfo(
  typeMap: ITypeMap,
  type: Type<ts.Type>,
  text?: string,
): string {
  let typeInfo: ITypeInfo = { type: DataType.others };
  if (type.isArray()) {
    const childKey = addTypeInfo(typeMap, type.getArrayElementTypeOrThrow());
    typeInfo = {
      type: DataType.array,
      param: childKey
        ? {
            '': { ref: childKey },
          }
        : undefined,
    };
  } else if (type.isTuple()) {
    typeInfo = {
      type: DataType.tuple,
      param: Object.fromEntries(
        type
          .getTupleElements()
          .map(
            (type, i) =>
              [i, { ref: addTypeInfo(typeMap, type) }] as [
                number,
                { ref: string },
              ],
          )
          .filter(([, { ref }]) => ref),
      ),
    };
  } else if (type.isClassOrInterface() || type.isObject()) {
    const properties = type.getProperties();
    const param: ITypeInfo['param'] = {};
    for (const property of properties) {
      let propertyType: Type<ts.Type> | undefined = property
        .getValueDeclarationOrThrow()
        .getType();
      let optional = property.isOptional();
      if (propertyType.isUnion()) {
        propertyType = getOnlyObjectType(propertyType);
        optional = true;
      }
      const childKey = propertyType && addTypeInfo(typeMap, propertyType);
      if (childKey) {
        param[property.getName()] = {
          ref: childKey,
          optional,
        };
      }
    }
    typeInfo = { type: DataType.object, param };
  }

  // Filter uninteresting types
  if (typeInfo.type !== DataType.others) {
    const key = getTypeHash(typeInfo);
    typeMap[key] ||= {
      info: typeInfo,
    };
    if (text && !typeMap[key].text) {
      typeMap[key].text = text;
    }
    return key;
  }
  return '';
}

function getRulesFromTypes(typeMap: ITypeMap): IGuardMap {
  return Object.fromEntries(
    Object.entries(typeMap)
      .map(
        ([key, { info }]) =>
          [key, getRuleFromType(info)] as [key: string, guard: IGuardType],
      )
      .filter(([, { type }]) => type !== DataType.others),
  );
}

function getRuleFromType(info: ITypeInfo): IGuardType {
  const result: IGuardType = {
    type: info.type,
  };
  if (info.type !== DataType.others) {
    result.rules = sortedEntries(info.param).map(
      ([name, { ref, optional }]) => {
        const rule: IGuardRule = [ref, name, optional ? 1 : 0];
        // Compact data
        while (rule.length > 0 && !rule.at(-1)) {
          rule.pop();
        }
        return rule;
      },
    );
  }
  return result;
}

function sortedEntries<T = unknown>(
  obj: Record<string, T> | undefined,
): [string, T][] {
  if (!obj) {
    return [];
  }
  return Object.keys(obj)
    .sort()
    .map((key) => [key, obj[key]]);
}
