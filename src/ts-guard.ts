import { mkdir, writeFile } from 'node:fs/promises';
import { resolve, relative, dirname } from 'node:path';
import {
  CallExpression,
  Project,
  ProjectOptions,
  ScriptTarget,
  ts,
  Type,
} from 'ts-morph';

const TS_GUARD_TEMPLATE = process.env.TS_GUARD_TEMPLATE;

enum DataType {
  others,
  object,
  array,
  tuple,
}

interface IArrayTypeInfo {
  type: DataType.array;
  param?: ITypeInfo;
  optional?: boolean;
}

interface IObjectTypeInfo {
  type: DataType.object | DataType.tuple;
  param?: Record<string, ITypeInfo>;
  optional?: boolean;
}

interface IOtherTypeInfo {
  type: DataType.others;
  optional?: boolean;
}

type ITypeInfo = IArrayTypeInfo | IObjectTypeInfo | IOtherTypeInfo;

type IGuardRule = {
  /** The name of the current field. */
  name: string;
  /**
   * The properties of the current field.
   *
   * 0b 0 00
   *    |  |
   *    |  +---- type of the field (`flag & 3`)
   *    +------- whether the field is optional (`(flag >> 2) & 1`)
   */
  flag: number;
  /**
   * The field rules of this object, only applicable when the current field
   * is an object or an array of objects.
   */
  children?: IGuardRule[];
};
type ICompactGuardRule = [
  flag: number,
  name?: string,
  children?: ICompactGuardRule[],
];

type ITypeMap = Map<string, { id: number; info: ITypeInfo; text?: string }>;

type IGuardInfo = [CallExpression<ts.CallExpression>, string];

export interface ITsGuardBuildOptions {
  /**
   * The root directory of ts files that ts-guard should compile.
   */
  rootDir: string;
  /**
   * The path of the file that contains type data generated by ts-guard.
   */
  guardFile?: string;
}

let id = 0;
const typeMap: ITypeMap = new Map();

export function compile(
  buildOptions: ITsGuardBuildOptions,
  projectOptions?: ProjectOptions,
) {
  /**
   * `outDir` is passed to tsc as `compilerOptions.outDir` and used to calculate file paths in the memory.
   * It does't affect the path of files written to the local file system.
   */
  const outDir = 'lib';
  const project = new Project({
    tsConfigFilePath: 'tsconfig.json',
    ...projectOptions,
    compilerOptions: {
      ...projectOptions?.compilerOptions,
      sourceMap: false,
      target: ScriptTarget.ESNext,
      rootDir: '.',
      outDir,
    },
  });
  const { rootDir } = buildOptions;
  let guardFile = buildOptions.guardFile || `${rootDir}/_ts_guard.ts`;
  guardFile = guardFile.replace(/\.jsx?$/, '.ts');
  updateGuards(project, scanFiles(project), guardFile);
  // project.emitSync();
  const result = project.emitToMemory();

  const baseDir = resolve(outDir, rootDir);
  const files: Record<string, string> = {};

  for (const file of result.getFiles()) {
    const relpath = relative(baseDir, file.filePath);
    if (!relpath.startsWith('../')) {
      files[relpath] = file.text;
    }
  }

  return files;
}

export async function writeFiles(
  files: Record<string, string>,
  outDir: string,
  callbacks?: {
    onWriteFile?: (relpath: string) => void;
  },
) {
  for (const [relpath, content] of Object.entries(files)) {
    const fullPath = resolve(outDir, relpath);
    await mkdir(dirname(fullPath), { recursive: true });
    await writeFile(fullPath, content, 'utf8');
    callbacks?.onWriteFile?.(relpath);
  }
}

function guardType(type: Type<ts.Type>) {
  // const key = type.getSymbolOrThrow();
  const key = serialize(getTypeInfo(type));
  const text = type.getText().split('.').pop();
  let value = typeMap.get(key);
  if (value === undefined) {
    typeMap.set(
      key,
      (value = {
        id: ++id,
        info: getTypeInfo(type),
        text,
      }),
    );
  }
  return { value, text };
}

function getGuardInfo(
  project: Project,
  node: CallExpression<ts.CallExpression>,
) {
  const propArg = node.getArguments()[1];
  const prop = propArg?.getType().getLiteralValueOrThrow() as string;
  const typeChecker = project.getTypeChecker();
  const signature = typeChecker.getResolvedSignatureOrThrow(node);
  const responseType = typeChecker.getReturnTypeOfSignature(signature);
  const type = prop
    ? responseType.getPropertyOrThrow(prop).getTypeAtLocation(node)
    : responseType;
  const { value, text } = guardType(type);
  return [node, `/* ${text} */ ${value.id}`] as IGuardInfo;
}

function scanFiles(project: Project) {
  const sourceFiles = project.getSourceFiles();
  const filesWithGuard: [string, IGuardInfo[]][] = [];
  for (const sourceFile of sourceFiles) {
    // console.log("Visit file:", sourceFile.getFilePath());
    const guards: IGuardInfo[] = [];
    sourceFile.forEachDescendant((node) => {
      if (!node.isKind(ts.SyntaxKind.CallExpression)) {
        return;
      }
      const identifier = node.getExpressionIfKind(ts.SyntaxKind.Identifier);
      const identifierName = identifier?.getText();
      let guard: IGuardInfo | undefined;
      if (identifierName === 'tsGuard') {
        guard = getGuardInfo(project, node);
      }
      if (guard) {
        guards.push(guard);
      }
    });
    if (guards.length > 0) {
      filesWithGuard.push([sourceFile.getFilePath(), guards]);
    }
  }
  return { typeMap, files: filesWithGuard };
}

function updateGuards(
  project: Project,
  { typeMap, files }: { typeMap: ITypeMap; files: [string, IGuardInfo[]][] },
  guardFilePath: string,
) {
  const ruleMap = getRulesFromTypes(typeMap);
  const rules = Object.entries(ruleMap).map(
    ([key, { rule, text }]) =>
      `/* ${text} */
${key}: ${JSON.stringify(compactRule(rule))}`,
  );
  const template = TS_GUARD_TEMPLATE.replace(
    /{\s*\/\* RULE_MAP \*\/\s*}/,
    `{\n${rules.join(',\n')}\n}`,
  );
  const guardFile = project.createSourceFile(guardFilePath, template);
  for (const [path, info] of files) {
    const sourceFile = project.getSourceFileOrThrow(path);
    let guardPath = sourceFile.getRelativePathTo(guardFile);
    guardPath = guardPath.replace(/\.tsx?$/, '.js');
    if (!guardPath.startsWith('.')) {
      guardPath = `./${guardPath}`;
    }
    sourceFile.addImportDeclaration({
      moduleSpecifier: guardPath,
      namedImports: ['$tsGuard$'],
    });
    for (const [node, id] of info) {
      const identifier = node.getExpressionIfKind(ts.SyntaxKind.Identifier);
      if (!identifier) {
        continue;
      }
      identifier.replaceWithText('$tsGuard$');
      node.insertArgument(0, id);
    }
  }
}

function getTypeInfo(type: Type<ts.Type>): ITypeInfo {
  if (type.isArray()) {
    return {
      type: DataType.array,
      param: getTypeInfo(type.getArrayElementTypeOrThrow()),
    };
  }
  if (type.isTuple()) {
    return {
      type: DataType.tuple,
      param: Object.fromEntries(
        type.getTupleElements().map((type, i) => [i, getTypeInfo(type)]),
      ),
    };
  }
  if (type.isClassOrInterface() || type.isObject()) {
    const properties = type.getProperties();
    const result: Record<string, ITypeInfo> = {};
    for (const property of properties) {
      const propertyType = property.getValueDeclarationOrThrow().getType();
      result[property.getName()] = {
        ...getTypeInfo(propertyType),
        optional: property.isOptional(),
      };
    }
    return { type: DataType.object, param: result };
  }
  return { type: DataType.others };
}

function getRulesFromTypes(typeMap: ITypeMap) {
  const ruleMap: Record<number, { rule: IGuardRule; text?: string }> = {};
  for (const { id, info, text } of typeMap.values()) {
    if ([DataType.array, DataType.object].includes(info.type)) {
      const rule = getRuleFromType(info);
      if (rule) {
        ruleMap[id] = { text, rule };
      }
    }
  }
  return ruleMap;
}

function getRuleFromType(info: ITypeInfo, name = ''): IGuardRule | undefined {
  if (info.type === DataType.array) {
    const child = info.param && getRuleFromType(info.param);
    const result: IGuardRule = {
      name,
      flag: calcTypeFlag(info.type, info.optional),
    };
    if (child) {
      result.children = [child];
    }
    return result;
  }
  if (info.type === DataType.object || info.type === DataType.tuple) {
    const children =
      info.param &&
      (Object.entries(info.param)
        .map(([key, value]) => getRuleFromType(value, key))
        .filter(Boolean) as IGuardRule[]);
    const result: IGuardRule = {
      name,
      flag: calcTypeFlag(info.type, info.optional),
    };
    if (children?.length) {
      result.children = children;
    }
    return result;
  }
}

function compactRule(rule: IGuardRule) {
  const data: ICompactGuardRule = [rule.flag];
  if (rule.name || rule.children) {
    data.push(rule.name || '');
  }
  if (rule.children) {
    data.push(rule.children.map((child) => compactRule(child)));
  }
  return data;
}

function serialize(info: any): string {
  if (Array.isArray(info)) {
    return '[' + info.map((child) => serialize(child)).join(',') + ']';
  }
  if (info && typeof info === 'object') {
    return (
      '{' +
      Object.keys(info)
        .sort()
        .map((key) => `${JSON.stringify(key)}:${serialize(info[key])}`)
        .join(',') +
      '}'
    );
  }
  return JSON.stringify(info);
}

function calcTypeFlag(type: DataType, optional?: boolean) {
  return (+!!optional << 2) + type;
}
